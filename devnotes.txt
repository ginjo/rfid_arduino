/*  RFID PRoximity Sensor Dev Notes  */



TODO: √ Close fuel switch at startup, so we don't have to wait for software load.
      But track if there was a 'fatal' missing-tag timeout, using EEPROM.
      If there WAS a previous timeout, keep fuel switch OPEN at startup,
      until a valid tag is read (then clear the 'fatal' event from EEPROM.

TODO: √ LED blinker needs a refactor: 1. Simplify, 2. Allow cycle count passed to begin();
      Done except for cycle count.

TODO: √ Implement blinker cycle limit setting.

TODO: √ I think macros need to be coordinated between each file, since they can clobber each other.
      Most macros can be turned into settings (S.<setting>).

TODO: √ Create menu options to set global variables. See above about macros.

TODO: - Create var-to-eeprom address mapping for common settings (to be editable by menu).
      I think this is no longer needed, since we're using EEPROM.put(<with-a-struct-object>).

TODO: √ Provide standard message when admin menu exits/transitions to run mode.

TODO: √ Sort out git repos in Documents/Arduino folder.

TODO: √ Don't allow admin mode to extend the startup grace period.

TODO: √ Implement a beeper/buzzer.

TODO: √ I think SerialMenu.run_mode should be a global, since it's needed in multiple classes.
      But where should it live? Then logging can have its own file/class,
      and it can access multiple serial outputs, maybe?
      Update: Maybe run_mode should be a member of the RFID class (Controller class?).

TODO: √ Consolidate SerialMenu handling of input between checkSerialPort() and runCallbacks(),
      so basically everything should be a callback.

TODO: √ Create exitAdmin() function for cleanup & logging.

TODO: √ Make the common blink patterns into constants or S.<setting>.
      fast_blink_intervals[], slow_blink_intervals, startup_admin_timeout_intervals[], etc..
      Still need to store these common intervals in S.<settings>.

TODO: √ Startup grace period needs to END immediately after startup,
      if NO tags are found after the FIRST reader power cycle.
      √ At this point, proximity_state and S.proximity_state need to be fully timed-out.

TODO: - Consider renaming S.proximity_state to S.last_proximity_state.
      Update: proximity_state has been moved to Controller class.

TODO: √ Fix bug in addTagString (I think it's input_mode issue).

TODO: √ Consider a function setProximityState(on-or-off, hight-or-low, whatever).

TODO: √ Add status_text and updateStatusText() to efficiently display status change in logs.
      This should display proximity_state status as text-label, whenever it changes.
      Use enum StatusText {recent, aging, expired}.
      
      Update: do we still want this? Is it possible?
      
      Update: This is now handled.

TODO: √ Reduce active logging lines in SerialMenu serial port reading.

TODO: √ Show S.<settings> values along with list (in admin mode).

TODO: √ Complete add-tag and delete-tag processes.

TODO: √ Save tags to EEPROM.

TODO: √ Also implement add-tag-from-scan option.

TODO: √ Create version & date-time handling.

TODO: √ Reorganize functions so that "rfid" tag functions are in RFID class,
      "menu" functions in SerialMenu class, and "settings" functions in Settings class.

TODO: √ Consider using variadic macros to create a LOGGER that can print to variable outputs.
      See http://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html
      You might need to include stdarg.h.
      Update: Now have LOG() function, but it isn't a macro.

TODO: √ Tag output to serial console is always the same tag, regardless of what was scanned.
      This holds true even after cold restart of entire board.

TODO: √ Need to ignore READER_CYCLE_HIGH_DURATION at beginning of run mode,
      and cycle reader immediately if no tag found yet. Then immediately
      timeout the tag if still not found.
      This is all because READER_CYCLE_HIGH_DURATION could be set rather high,
      and would allow too much grace period at startup.

TODO: √ cycleReaderPower() isn't triggering when READER_CYCLE_HIGH_DURATION is set to 50,
      and tag-timeout is set to 60. So there's a timing issue when settings are not 5, 25 respectively.
      This was an issue with integer arithmatic and not enough bits.

TODO: √ Maybe refactor proximityStateController() to have smaller conditions and more else-if blocks.
      Also move the subconditions to a single flat if-then-else statement.

TODO: √ Require a CR or CR/LF to enter single characters for SerialMenu.
      This might just be a matter of always using 'line' mode instead of 'char' mode.
      This is necessary to use some terminal apps like BLE-Terminal on ios
      to use the BLE (HM-10) adapter on arduino. Also consider HM-12 for dual BT access (2.1, 4.0).

TODO: √ If proximity state goes low, set reader-cycle-high duration to 3 or 5 seconds.
      Otherwise a flakey tag sitting on top of the reader may miss its only change to be read
      in the scenario where tag-timeout and reader-cycle are both set very high.
      May need a class-global variable for that purpose, so we don't have to mess
      with the S.<setting>.

TODO: √ In normal operation, after admin session timeout (or '0' quit),
      proximity-state is being briefly set to 0, even though the reader hasn't cycled yet.
      This needs to be fixed so startup grace-period NEVER times out without
      first trying a reader power cycle.

TODO: √ Finish converting reader_power_cycle_high_duration to readerPowerCycleHighDuration()

TODO: ! Create protection/failsafe against user-input of bad/empty/out-of-bounds settings.
      For example admin_timeout should NEVER go below 5s,
      And the initial admin_timeout of 2s should not be modifiable by user.
      Generally make sure the Arduino cannot be bricked (requiring a re-flash).
      Update: Some protections have been added to SerialMenu class, but more are needed.
      √ A failsafe boot mode would be helpful.

TODO: √ Create a setting & control for reader-power-cycle polarity.
      Yes, but this is now done in the Reader (sub) classes.

TODO: √ Complete the Reader function that decides what reader to use.

TODO: √ Convert settings, readers, led patterns to lists & enums, if possible. (settings are done).
      √ Also create settings for all possible current uses of literal data,
      mostly numbers, but maybe some strings?
      Update: This todo item might only make sense for led patterns now,
      since the rest of the entities are already competently handled.
DONE: √ Finally fixed the nasty bugs in RFID and Reader, well most anyway. Ongoing search for UB.

TODO: √ Try swapping the RFID::loop() functions back to the way they were... Still work?

TODO: √ Try converting other RFID uses of tag_last_read_timeout_x_1000 to tagLastReadTimeoutX1000().

TODO: - Consider instance vars in Reader for last_tag_read_id and current_tag_code (hex, I think).
      This is trickier than it seems because it would create a circular requirement between classes.
      Turning the logging features into their own class might help.
      Update: With latest structure, this might be easy now.
      We have a Reader::last_tag_read_id, so this issue might be moot now.

TODO: - I got debug logging to work with BTmenu, but it breaks the RFID cycle.
      It prevents the Reader instance for processing the tag. Is this also a UB whack-a-mole thing?
      Update: the problem appears to be that the RFID serial channel is getting garbled data,
      or at least the program is seeing it as garbled. So, I disabled the BTmenu logging.
      This was probably a UB thing, possibly unrelated to this issue.

TODO: √ Put all literal data that hasn't been incorporated into Settings into macros.

TODO: √ Find a way to use F() to wrap Settings var names in getSettingsByIndex().

TODO: √ When power is first applied, reader-reset-pin appears to be held low indefinitely,
      and reader failes to read tag (after the first one at boot time).
      But even when reader is manually triggered, Ard fails to process the tag successfully.
      A warm (not cold!) reboot of the Ard is necessary to get it working again.
      Update: this only happens in production mode - in debug mode, the reader works fine. Arrrgg!
      √ Update: I might have fixed this - that pin didn't have a pinMode() call, leaving it floating.

TODO: √ Booting under external power in debug mode (debug pin) is causing problems,
      maybe because of a load-order thing with INO_PRINT. But this doesn't seem to happen
      when powered by USB.
      Update: The whole power-on bug was because load order wasn't allowing objects to initialize
      before being used.

TODO: √ Find string operations that have 0 as an argument, and see if they should use '\0' instead.
      According to docs 0 is same as '\0'. They are both int's.

TODO: √ Cleanup & fix bugs in SerialMenu UI.
      √ Prompt
      √ Empty selection for settings-menu.

TODO: √ Output Settings list to HW Serial on starup.
WARN: - Program storage space is at 80% usage.
      - Might need to move some strings back to SRAM (by eliminating F function for some).
      Update: This problem has been aleviated with class-specific debug control.

TODO: √ Create SETTINGS_VALUE_SIZE and use it for calls to getSettingByIndex().

TODO: √ Functionally, everything is working, but S.getChecksum is returning a different number
      between boot and first loop.
      Update: It appears to be the out-of-range dummy ports. Stop using them!
      Ok, this is fixed now! Don't use out-of-range pins, will cause UB.

TODO: - With debug pin, don't change S.enable_debug, because saving any setting
      will then save enable_debug as 1. Just read the pin directly.
      Update: It's ok, just don't boot with debug pin low for an admin session where you save settings.
      You can always hold debug pin low after boot, for temporary debug mode.

TODO: √ Create a Settings function 'debugMode()' which compiles enable_debug with debug-pin.
NOTE: √ Milestone achieved! All basic functions required for real-world use are working.
//

TODO: √ Smooth out UI functionality in SerialMenu - it's still a little confusing what
      mode/state/options we're in at each prompt. Maybe there should be no generic prompts,
      always give a textual hint.

TODO: √ Rearrange main .ino file load order, so initial proximity_state gets written out
      to master-switch-pin as early as possible.

TODO: √ Something is wrong with Tags checksum: it's the same for two different lists!

TODO: - Make tags checksum at least 32-bit. Actually, the 16-bit checksum works now.

TODO: √ Don't load all readers, only load the one we're using.

TODO: √ Create an initial_state (for the grace period) setting: 0=off, 1=on, 2=last-known (S.proximity_state).
      - This may also require an initialState() function to compile the various settings/options at runtime.


FOR REFACTOR:

TODO: √ Move reader functions of RFID class into Reader base,
      then use the loaded reader only for reader functionality,
      including cycling and tag parsing, but not master-switch management
      or led triggering or Tag operations like add, delete, authentication (validation?).
      √ Maybe move reader subclasses to their own readers.cpp file.

TODO: √ Create a Gate/Switch/Controller/State? class that handles all the other stuff RFID does now.
      This class should take a Reader and Blinker instance onboard, since it's the glue
      between those two entities.
      √ Update: This is now just a matter of renaming the RFID class to something else, like Controller.

TODO: √ Then create a Tags class that manages everything tag-related (that's not part of Reader).

TODO: √ Consider again having a Storage class that Tags, Settings, and State all subclass from.

TODO: √ Create a fail-safe button and/or a restore-defaults button. Done: hold pin 12 LOW.

TODO: √ Have BTmenu listen on hardware serial as well.

TODO: - For callback functions or event-response functions, consider "onBufferReady()" naming style.
      Examples: onTagReady(int tag_id), onMenuAddTag(), onSerialPortData(byte).
      Really? Do we want truly event-driven behavior? Would it be better to put a ready-tag
      in a static-member var, and let whatever function pick it up?
      Update: What we've done in SerialMenu with callbacks is sorta like this and works well.

TODO: √ Change Settings::current to title-case Settings::Current.

TODO: √ Don't use strcpy or strncpy. DO use strlcpy (it ensures a null terminator).
NOTE: √ Milestone achieved! Created generic Storage base class, that is also a class template (CRTP).
      √ Settings are currently using this... next are tags (need a Tags class where 1 record is array of tags).

TODO: √ Refactor Storage Class, saving all needed data (including EEPROM address) in Storage instance.
      See storage.h. (also maybe mentioned in other places too, like Tags. storage.h should be the official TODO).
NEXT: √ Storage refactor compiles. Now need to decouple it from the other classes, then review code, then try it.
      √ This has been done with Tags, next do with Settings (then with State - for proximity_state).

TODO: ! Need validation routine in Tags or Reader to handle bad tag-id.
	    Make sure that checksum is used to validate tags.

TODO: √ Handle reader looping for add-tag entirely within serial-menu class.
      √ Reader class should be unaware of SerialMenu instances.

TODO: √ Implement more efficient GetReader, and move to Reader::GetReader().
      See example file "C++ polymorphism with factory pattern in base.cpp".

TODO: √ Can all specific reader declarations/definitions go into a single file "readers.cpp" ???
      Yes, as long as the GetReader() function is also moved to readers.cpp.

TODO: √ Consider function pointers for SerialMenu callbacks, instead of the large switch/if/then statements.

TODO: √ menuAddTag and addTag are all messed up, in different ways, for both HW & SW interfaces.
      √ Need to make sure that SerialMenu class always cleans up after doing anything with menuAddTag.
      √ Currently, a messy state causes the run-level 0 to behave eratically, switching on/off the proximity-state
      eeeprom setting repeatedly.
      √ Letting SerialMenu timeout naturally and go into run-mode 0, also leaves a mess,
      yielding authorized tags but never activating the switch.
      LED remains in boot state.
      Update: I think most of this issue is solved, was UB from out-of-mem condition.
      Double-check on BTserial interface.

TODO: √ Remove stuff from SerialMenu and Reader that isn't used any more.
      √ Remember to check obsolete macros and global vars in .h files.

TODO: √ Include uptime in cycleReaderPower periodic output.

TODO: √ Don't forget failsafe mode and reset-factory-defaults command.
	  Done: Hold pin 12 LOW for failsafe boot. Save any setting to overwrite stored settings.

TODO: - Undo the timing changes around calls to listen() for both soft-serial ports.
      Then split the whole menuAddTag into two functions: one for scanner and one for tty serial.
      Update: timing issues between menu & reader are now working.

TODO: √ Consider disabling all clearing of serial ports, unless they are solving a specific problem.
      It's only done once anyway.

TODO: √ Longer delays may actually hinder serial ports. Consider shorter delays placed more strategically,
      like as long before the port needs to be read as possible. 

TODO: √ Implement backspace/delete (ascii 127, 8) for tty. May need to use form-feed chr also (12).
	    So far, having an "Esc" key abort seems to suffice.
	    
	    Update: got it working!

TODO: √ Create FREERAM macro that only runs if debug mode. Use it everywhere u have FreeRam() now,
      except at startup & other key places.

TODO: - Remove Blinker from SerialMenu -- there's really no need for it there.
      Partially done: disabled call to Blinker in Menu.

TODO: √ Rename SerialMenu to just Menu.

TODO: √ Rename RFID to Controller or Switch.

TODO: √ Re-enable proximity_state EEPROM retrieve/save (see above for initial_state suggestion).

TODO: √ Review organization and labels in main .ino file.

TODO: √ Test the latest build, since the logging code changes.

TODO: √ Test changes to RGB implementation.

TODO: √ Store pin assignments in code, not in settings.
      
TODO: √ Store settings in code for all actual physical hardware settings.
			Pin assignments have now been stored as macro vars (global).
			Anything that is set through software or digital commands should be
			adjustable by the user or developer.

TODO: - Handle saving of blinker interval-set, so previous set can be
      revived after cycle-count goes over num-cycles.
      An led-pattern-stack?
      See note in Led::startPhase(int).
      
      This has sorta been handled in a different way.
      
TODO: √ Consider reducing reader cycle interval to 3 sec whenever state goes to aging.
      This is because there could be a 30+ second aging length, which would only
      cycle the reader once during that entire time (twice if you count the initial cycle).
      See controller.cpp proximityStateController() and setProximityState().
      
      √ Move the setting of reader_power_cycle_high_duration into
      proximityStateController() and out of setProximityState().
      

TODO: √ Create an off() and on() function that simply sets LED pin accordingly
      but doesn't change cycle state or intervals.
      Update: New go_low() and go_high() set software state and electrical state.
      This works much better than using Off() to clear the red LED when blue wants
      to flash a momentary indicator.

TODO: √ Create a io.h file with all pin assignments.

TODO: √ Make beeper frequency a setting.
      
TODO: √ Allow blinker frequency & pwm to be passed during construction,
      and also at update() or begin().
      
TODO: √ Make sure that defaults for update() and begin() don't override
      values passed during construction (this is handled with negative
      argument-defaults).
      
TODO: √ Since hardcoding pin assignments, find where you had to compromise
      functionality due to waiting for settings to load pin assignments.
      Was it in logging? In LED stuff? In BT admin menu?
      
      √ Hard-coded pin assignments may allow some startup routines to
      start logging earlier, or to begin themselves earlier.

TODO: ? Should the piezo buzzer be located with the RGB LED?
			What does this mean?

TODO: √ Setting tone_frequency from BTLE terminal gives weird results.
      I think it depends on the terminal client, cuz it works fine with
      "AirTerminal" on iPhone.

TODO: - Activating menu session with BTLE is almost impossible with 2-second window.
      √ Allow increasing admin-startup window with a setting.

TODO: √ Use BT12 connection status indicator (pin 10, low = connected) to 
      tell ARD there is an active connection, or that the connection has dropped.
      
TODO: √ Create a setting 'log_mode'. If true, send all logs to BT-serial port if BT-serial is active.
      This can only be activated during admin mode, however once set, it can be left alone.
      While log_mode is set, any connection to BT-serial port will receive logs, until log_mode is disabled.

	    √ 1. Find out which arguments Serial.print() takes.
	  
  	  √ 2. Then create a wrapper function, ex: "LogToBT()", that takes those args.
  	  	 If conditions are met to write to BTserial,
  	  	 pass the args to BTserial.print(), noting that parameter mismatches
  	     between Serial.print() and the new function may occur and need to be handled.
	  
	    - 3. Optionally, create LPRINT and LPRINTLN macros to wrap the above function.
	  
  	  √ 4. Finally, replace all occurrences of Serial.print() with
  	     the new function (or macro), and you should be good to go.
	  
  	  5. - Handle DPRINT and the passing of its args (to BTserial)
  	     after all of the above is working.
  	     
  	  6. - Consider a 'Log to BT' command at main menu level, that sets log_to_bt then exits admin.

TODO: √ Create 'Reboot' command.

TODO: √ Change log_to_bt setting to bool (currently integer). Mostly to reduce storage space.

TODO: - Debug scratching sound during timeout beeping, when log_to_bt is set.
      I think it's because log output to BTserial interferes with ARD PWM.
      Probably nothing we can do about it.

TODO: √ Move admin console splash line to after LOG items finish printing
	    (only relavent when BTserial is printing startup logs).
	    Ok, mostly done.
	  
TODO: √ Get settings display to print to BTserial at startup.

TODO: √ Use debug-mode function, instead of raw pin read, in can_print_to_bt logic.

TODO: √ When debug pin is held during run mode, it makes a mess of the reader/controller/blinker/beeper.

TODO: √ There is garbage printing on BTserial at startup, even when log_to_bt is 0 and debug-pin is 1 (off).
      Maybe UB caused by the multiple BTserial declarations.
      
      Update: I think it's due to floating pins, cuz is never happens when soft-rebooted from IDE.\
      Or it's from UB.
      
TODO: √ Check to see if any class constructors are using LOG or BTserial in their construction methods.
      They probably should not.
      
      Yes, Reader (individual readers) has LOG in its constructors.
      This does not seem to be breaking anything right now.
      Leave alone.

TODO: √ Change io.h to global.h, and put externs (like BTserial) in there.

TODO: √ Create a io-setup or globals-setup extern function,
      and put all pin setups in there,
      then call it at beginning of main setup().
      
TODO: √ Debug mode (with debug-pin) now crashes ARD.
      Maybe some kind of interference between io ports or pins?
      
      √ There was UB occuring due to multiple declarations of BTserial.
      Now BTserial is declared & defined in io.h and io.cpp... and it works!
      
TODO: √ Why is WL-125 constructor running twice (see log output)?
      Hmm... it's by design. See GetReader() and TestReader().
      There must be a better way to do this.

TODO: √ Users need to see what readers are available, when selecting in settings.
      This is mostly handled now with PrintReaders (main menu item #7).

TODO: - Consider changing Reader::GetReader() to Reader::Setup()

TODO: - Consider if making Reader or Reader::Reader() a template
      will help reduce redundant/duplicate code in subclass reader defs (in readers.cpp)
      See the old TestReader() function (readers.cpp) for ideas.
      
      Update: I don't think this would help, plus it would require putting the
      contents of reader.cpp into reader.h.
      
TODO: √ Make reader index/name mapping 1-based (not zero-based).

WARN: - Use of 'char *var' declarations at static and class level
      may cause out-of-bound strings and UB.
      This may be an issue for the reader-name refactor.
      
      √ I think we need to give Reader::Name and maybe Reader.reader_name defined length.
      
      Setting this warning aside for now, since none of these items fixed the UB.
      
TODO: √ Change Reader.reader_name() to Reader.name().

TODO: √ Change all '.debugMode() > 0' back to just '.debugMode()'

TODO: √ Add dedicated extern or static var to hold hardware debug state from startup.
      Currently we are using S.enable_debug, which will get set into EEPROM if any
      other settings are stored.
      
FIX:  √ Updating deafult_reader setting using reader list (or main menu #7) fails.
      Turns out you can't just cast an int to char*.
      Turns out the PrintReaders function was overrunning its output buffer var.

TODO: √ Make sure no other Menu code prints to BTserial when it shouldn't.
      Turns out the initial menu prompt was causing BTserial chip to throw "ERROR".
      
FIX:  √ Storage can't use DPRINT cuz Settings and logger.h haven't been loaded yet.
      So just use LOG within #ifdef SO_DEBUG blocks.
      
TODO: √ Don't overwrite existing tag set when loaded tag set has checksum mismatch.
      Just run with a zeroed tag set, but don't save it to eeprom.
      Allow the user to make the decision to save.
      
TODO: √ Move TempDebug to logger or global files.

TODO: √ Actually, consider consolidating logger and global files
      and moving all debug code from settings to logger/global files.
      Mmm... This won't buy us anything right now, so let's leave alone.
      
TODO: √ Create a proper logger that consolidates all the c++ macros with the
      existing LOG function.
      
TODO: - Create empty-prompt function for Menu, that just basically pauses and waits for any key
      Then continues on to specified callback. This might help the Reader menu & selection
      prompt that is the first event after the user inputs something.
      
TODO: √ Make reader selection an eternal loop, with only a CR to break out of it.
      This is just like with settings.
      
TODO: √ Missig some log items in BTserial when only log_to_bt is set (no HW pin).
      Yep, because stored Settings have not been loaded yet, causing canLogToBt()
      to return false. Nothing we can do about this. Just use the debug pin, if you
      want to see the earlier log output in the BTserial monitor.

TODO: √ Debug-logging clobbers HW menu interface when debug-pin is used.
      Logging to HW interface should be minimal when HW serial menu is active.
      
      Ok, now all log-trace output is sent only with level 6.
      Not sure how to handle this issue though, when we need
      to view trace logging for classes with lots of looping log output.
      
      Update: I think this is mostly fixed with current logging scheme.
      
NOTE: Standard log output should always show what is about to happen, not what just happened.
      This will give you more info in case of a failure/crash/error.
      Debug log output should add the "what just happened" info.
      Or do I have this backwards?
      
      Example (for info logging):
        Loading settings
        Loading tags
        Starting controller
        Starting reader
        
      Example (for debug or trace logging):
        Loaded settings
        Loaded reader
        Loaded tags
        Loaded controller
        
TODO: √ Remove unnecessary delay()s.

TODO: √ Create functions for reading/writing to BT12 module.
	  
TODO: √ Should run_mode and adminTimeout() be stored & handled from Controller (instead of Menu)?
      A review showed that this could be done, however Menu is by far the largest
      consumer of run_mode, AND it is the only place where run_mode is written to.
      So let's keep this stuff in Menu for now.
	  
TODO: √ Review naming of static/extern/global vars and functions.

TODO: √ Only run AT commands to SW serial if module is not connected.

TODO: √ Prevent lockout if SW admin invokes command 9 (send AT commands).

TODO: √ Created basic logging framework and converted Menu class.
      Now upload and try it.
      Then convert other classes.
      
TODO: √ FIX: Tags list at startup shows a single string of letters.
      This was due to several LOG calls with the wrong level.
      I don't think there was any UB happening.
  
TODO: - Test all the new logging calls at level 6 with each class _DEBUG enabled.

TODO: - Can we poll HW menu in run-mode 0 for simple log-level changes (1, 2, 3, 4, 5, or 6).
      Or would that create a software-serial mess?
      Maybe only when debug button is LOW (or was LOW at startup)... ?
      
      Probably not: During run mode 0, the only SW serial listener should be the reader.
      
TODO: - Should debug button take level all the way to max (6)?
      See below for suggested refactor of Settings.debug_mode.

Fix:  √ Log level 5 with BTserial connected & with Reader debug enabled causes
      reader/controller confusion when tag is read, leading to false aging mode.
      (it's the reader byte detail that seems to cause the most trouble).
      The problem goes away immediattely when log level is reverted to 4, or when
      BTserial is disconnected. This is likely a sw-serial competition thing,
      since it doesn't happen at all using HW serial monitor.
      
      The only solution may be to always use HW serial to view log output,
      while using BT serial to view deeper levels of output is at-your-own-risk...
      
      Update: I think this was UB... I'm calling it done.
      
TODO: OR, try preventing switching of SW serial listener, whenever the RFID reader
      is in the middle of reading a tag. Maybe allow only ONE loop section to operate
      at a time: Either the RFID reader loop, or the BT serial loop.
      But would this break Menu tag functions?
      
TODO: √ Try installing NeoSWSerial (replacement for SoftwareSerial).
      This is available thru the Ard IDE library manager (very easy).
      
      This and AltSoftSerial don't work with this app, as it is now.
      
TODO: √ Add Controller.status to track which state controller is in,
      ONLY for the purpose of logging change-of-state without spitting
      out gobs of identical log lines.
      
TODO: √ Change log level of reader byte-detail output to 6 (instead of 5).
      This might prevent controller problems when viewing log level 5 (debug pin)
      in BT serial.
      
TODO: √ Prevent settings list for printing at startup if log level < 4.

TODO: √ Preface each log line with level name and Uptime().
      Must handle log items that are in the midddle of a line.
      
TODO: √ Make sure output switch is always on as early as possible, even before
      saved proximity-state is considered. This is so output-controlled devices
      (motors, pumps, etc) can power up per their original design.
      
      Do we need hardware for this?
      
      Update: Now it goes on as soon as the output pin is initialized.
      
TODO: √ LED is behaving weirdly, especially in aging and timeout states.
      The errors don't happen with Led debug enabled!
      
      Create log level 5 code for Led loop, like you did for Controller loop.
      
      This happens only after tag has had a successful read (triggering blue)
      and then has a timeout. That's when blue comes on mysteriously.
      
      Fixed: I added some housekeeping blinker[2]->off() statements in
      some key Controller places.

TODO: √ Take initial HW/SW serial baud rates from default Settings object,
      if possible, instead of being hard-coded.

TODO: √ With most delay() calls removed, Aging beeper is a little fast. Slow it down?

TODO: - Change WL-125 reader baud to 57600 if possile. Ooo, apparently NOT possible.

TODO: √ Reduce hardware buttons to only 1, will handle failsafe AND debug mode.
			Now startup looks like this with debug-button held low:
	    - debug enabled
	    - failsafe enabled
	    - debug re-enabled/disabled upon change from admin to run mode.

TODO: √ Change S.debug_mode to mean: What log level do we bump to during debug-pin or TempDebug?
      Will this work? Yes!
      
TODO: √ FIX: Now admin mode tag scanning is broken.
      OK, some delay after the RFID reader listen() statement seems to help.
      
      But now we have blue led popping up during admin mode after attempting to scan tag,
      and at the end of admin state the led just goes dark (green is going off)!
      
      All of this was UB from PrintUptime() char array overflow.
      
TODO: √ Instead of passing around intervals of addresses, try passing around just the static_intervals index.

TODO: - Try changing RGB to an array of values rather than an array of pointers.
        Led RGB[] = {Led(,RED_PIN, "Rd"), ...};
        Update: Tried it, didn't help anything, took more ram.
        
TODO: √ Tags::load() is complaining of checksum mismatch at every boot.

TODO: √ Change PrintUptime() to just Uptime(), which should only return a char array.

TODO: √ Remove all of the extra (uint32_t) casts in Reader, as they did not fix the UB and are not necessary.

TODO: √ Blue led is getting a negative cycle-count during general-timeout state.
			Was integer overflow in cycle_count.
        
NOTE: √ All of the UB appears to have been fixed.
			1. Was char array overflow in PrintUptime().
			2. Was integer overflow in Led::cycle_count.
			
TODO: - Make short-reader-power-cycle a bona fide setting.
			Is this really necessary? I don't think so, since the short cycles
			(1s at startup, 3s during timeout) are specific to certain situations.
			
TODO: √ Do the struct array thing with Menu items.
			√ You can probably use the CB typedef from Stack.
			√ Had to add menuListTags(void*) CB fp type to work with menuListTags(void*, CB).
			
TODO: √ Probably need menu-items-length and menu-item-name-length globals.
			
TODO: √ (security) Set up password protection for BT admin mode.

TODO: √ (security) Add short beep(s) when admin mode is activated.

TODO: √ (Security) Exit admin mode as soon as a tag is authorized (other than tag management).
			This means listening occasionally for tags.
			
			√Changed Uptime() and PreLog() to use static-const-char, instead
			of heap variable (new char[22]), for internal buffer. This is
			intended to reduce the liability of calling functions to free()
			the returned heap memory.
			
			√ It is not working correctly, results in old uptime data in buffer
				being written to log.
				
			√ Have changed it back to using heap allocation.

TODO: √ Disable automatic save for settings. Ask to save on settings exit.

TODO: - Should there be an option to enable/disable auto-save? Nah.

TODO: √ Consider making all indexed lists righ-justified for index column.
			Remember to leave space for the null-terminator in the sprintf statement.

TODO: √ When Settings::Load() is running, it uses the log level of the loaded settings,
			even if the loaded settings object is bogus. So log level (and any other settings)
			in the default-settings are not being honored during the brief time that the
			bogus Settings object is loaded into Current (durring boot).
			
			√ Suggest storing loaded Settings into temp variable until it can be verified.
			Then copy it to the Current location. Actually, handle this in Storage.
			
			√ Make Storage::Load() return bool instead of data. Don't change the passed-in
			data object if the loaded checksum doesn't match.
			
			√ Make most Storage log lines level 5, just the nitty-gritty ones level 6.
			
			√ Make sure Settings defaults are complete enough that you don't have to
			load a new generic Settings instance if the stored one is bogus. Same with tags.
			
TODO: √ Save settings needs better results/confirmation output.

TODO: √ Change name of enable_debug to 'debug_level'.

TODO: √ Sometimes the first Uptime() call is printing garbage. Still?
			
TODO: √ There is a delay when reader gets a bogus tag during aging cycle
			which can be heard as a lag in the fast-beep.
			
			Make sure that reader does not delay for anything during live run-mode.
			Also make sure nothing takes 'listen' away from reader during live run-mode.
			
			Hmm, this might just be due to the time it takes to read and process a tag.
			
			√ Yes, it is due to writing log output during tag read. Reducing log-level
			to 4 solves the problem.
			
TODO: - Rebase since last push to github, and update commit messages with more accurate data.

TODO: √ Remove Update() call from cycleReaderPower log line.

TODO: √ When using BT admin to add-tag, manual entry is not currently possible,
			probably due to tag reader hogging the loop.
			
			√ Fixed by making both Reader and Menu delay(100) at each listen. Not sure
			why this helps but it does!
			
			! Works well with USB power, but not so well with crappy 5v switching regulator.
			
TODO: √ Create a better 5v regulated power supply for entire project.
			The current regulator is crap-full of noise, or something, that is causing
			one or more components to behave unreliably.
			
			√ Try a LM7805 or LM2937 (automotive) or LM1117, with appropriate external parts, for converting
			12v unregulated to 5v regulated. See links in Programming/Arduino... folder.
			
			√ Tried a LM7805 with the recommended capacitors (on their spec sheet),
			and it works much better than the crapy cheap switching regulator.
			
TODO: - Consider using a rotating array of bytes for state.
			Update: Won't buy us anything, since current-position needs to be stored somewhere static.
			
TODO: √ Clean up and shorten ALL strings to reduce progmem usage.

TODO: Move debugMode() function from Settings to Logger.

TODO: √ Play beep (or two) when tag scanned in admin mode.

TODO: √ Fix led/beeper when calling with specific num-cycles. It gives inconsistent number of beeps.
			Sometimes it doesn't run at all.
			
			√ Maybe try calling off(), after cycle-count has reached its limit.
			
TODO: √ Beeper triggered durring add-tag is always 1 cycle shorter than specified.
			This means that a beep called with 1 cycle won't be heard.
			
			Update: Beeper and blinker issues have been fixed by refining the Led logic and cycles.
						
TODO: √ During admin, 4-quick-beeps after failed scan have a too-long first beep.
			This issue goes away after running an AT command. What is changing?
			
			Update: The extra-long beep is from the switching between listening to the Reader
			and the Menu. Calling the AT command menu item resets the SW menu, and this seems
			to fix the issue. So I put the same reset commands on SW at the point where Current
			is set, but only if 'this' is HW.

TODO: √ Make it so when Menu is waiting for tag scan, the cycle-reader function runs more
			often than 5 sec.
			
			- Should this be a setting? Like the 3-sec cycle when in timeout mode.
			
			Update: This issue is moot now with the progressive reader cycle decay.
			
FIX:  √ Select-reader menu flow is not working correctly and not storing selection.

TODO: - In Menu log level 6, 'bufferReady?' logging is spitting out too much data, when no bytes
			are in buffer.
			
			Update: gonna leave this alone, since it's required for deep debugging.
			
TODO: √ Make reader-cycle max duration 15 instead of 5.

TODO: √ Consider a soft-timeout-duration setting, separate from reader-cycle-high-duration,
			OR just change name of reader-cycle-high-duration to soft-timeout-duration. In that case
			leave the function readerCycleHighDuration() as is, and that can still pull data
			from the newly named (but essentially the same) soft-timeout-duration.
			
			This is one of those SW/HW architecture vs UI architecture issues. Which do we favor?
			Can a solution be found that satisfies both SW/HW and UI architecture?
			
			Update: Controller should use the S.tag_last_read_soft_timeout (was reader-cycle-high-duration).
							Reader should use readerPowerCycleHighDuration().
							
FIX:  √ See line 141 in Controller.cpp for needed repairs/updates resulting from the above changes.

			
FIX:  √ Reader-cycle-low is taking too long (3+ sec!) when progressive cycle decay is increasing.
      But once it reaches same interval as soft-timeout, it (cycle-low) works as expected.
      
      You need some kind of logging for when reader cycle gos high.
      
      Update: This issue is due to pollReader() skipping cycleReaderPower() because
      powerCycleHighDur() has doubled since reader went low.
      
      Update: Adding another condition (from cycleReader) to pollReader helped.
      
TODO: - Find a clean way to enable/disable progressive reader cycling decay.
			Update: With reader-cycle-high-max now, I don't think this is necessary.

FIX:  √ Make sure reader is cycled one last time before shift to AGING or TIMEOUT.
			This is an issue at startup when going to run mode. See next issue below...
			
			Idea: What if we just set cycle-high-override with (soft-timeout - 1),
			instead of setting it to exactly soft-timeout.
			
			Update: Made the changes, now just need to test... ok, all good!
      
FIX:  √ The quick tag reads during startup don't seem to be captured by the ARD and recognized
			as valid. Is this a dueling serial port issue? Or is this the same issue as directly above?
			
			Update: I think this was fixed by setting reader-cycle-override back to 1 upon exitAdmin().
			
TODO: √ What is the '2000UL' hard-code? Should it be a setting?
			I think it's to allow time for the tag to be read and processed
			after a reader power cycle.
			
			Update: 2000ms is a safe time to wait for tag read after power cycle.
			This is only used to decide when to begin TIMEOUT state.

TODO: √ To maximize soft-timeout period during runtime incidents, there should be
			a cycle_high_duration_max setting. Ultimately (sadly) the reader cycle should be kept
			low (5 sec?) during normal runtime, so a missing tag has the most soft-timeout period
			available that is reasonable. So with a soft-timeout of 15s and a cycle-high-max of 5s,
			you would have a minimum of 10s before soft-timeout and the associated alarm (plus the
			rest of your hard-timeout setting before hard-timeout is activated). This is good, because
			you don't want the soft-timeout alarm sounding as soon as a tag goes missing.
			
FIX:  √ Fix reader constructor log messages.

TODO: √ Mask sensitive data in logs at runtime (what about in menu?)
			Update: Mostly handled now, at least for log level 4.

FIX:  √ At startup, BT is sending "ERROR", which triggers admin mode.
			It only happens sometimes, and it happens more often with external power.
			
			Sometimes this admin mode never ends.
			
			Update: Was because prompt was writing login request to BT
			when BT was not connected. Fixed by not allowing prompt() to
			write to BT unless it's connected.
			
TODO: √ Make sure NOTHING else is writing to BT at startup, if not connected.
			
FIX:  √ Tag reads in the middle of the cycle interval are not pushing the next cyclic read
			forward. The cycle should account for recent manual tag reads, and restart the cycle timer.
			
TODO: √ Figure out the roll separation between pollReader() and cycleReaderPower().

DONE: √ Changed cycle-high-override and readerCycleHighDuration to return ms.
			This allows us to do simple decimal math in calculating cycle times.
			

TODO: √ Change name of "Reader cycle max" setting to something else.

FIX:  √ Typing in a too-long password at the login prompt will lock up the admin UI.
			Fixed by putting a limit on input buffer.

FIX:  √ Save Settings is still not showing a reliable response when using BT menu.

TODO: √ Consider dupe-tag check before list-full check.

FIX:  √ Blinker and Menu debug modes are too big for hardware, even with all other
			debugs disabled.
			
			Fixed by creating "Arduino as ISP" programmer with extra nano, and
			updating the target nano bootloader to the Uno bootloader, which is
			newer and smaller than the nano's "old bootloader" (otherwise works the same).

FIX:  √ Settings field, reader-cycle-max, needs to be able to handle much larger numbers than 255.
			Make it at least as big as the other timeout fields.
			
			Update: The problem was in the setter function. All good now.

TODO: √ Call menu-settings-save after modifying reader selection,
			and remove the suggestion text that is currently output.
			
NOTE: √ If serial port disappears when trying to upload to ARD,
			you might not have enough power. And/or you might have a semi-bricked target
			due to a bad upload that causes rapid repetitive reboots.
			
			Use the UsbAsp device to upload a new bootloader to the target.
			
NOTE: If an upload crashes during the writing process, you may have a corrupt boot loader,
			OR you maybe have serial issues. When this happens during upload using BT-serial,
			try using hard-wired serial instead.
			
TODO: √ Output is high for too long at immediate startup, before a state==0
			condition is recognized and pulls it low. Try to reduce the duration
			of this brief high without making it start later.
			Make it end sooner.
			
			Update: This happens because output-pin is set high when global.cpp loads.
			It is not considered again until Controller.begin.
			
			Try disabling the call from global.cpp. Maybe with the new bootloader,
			it won't be needed. Yes, this works!
						
TODO: √ At startup, after a couple of reader-cycle-low, the reader-cycle-low
			is held low for much longer than the prescribed setting. This also
			happens after a aging or timeout event, when a good tag is finally
			authorized. This does not happen if output starts high and never goes low.
			
			Update: I think we need a power-cycle-state boolean to know
			when to call cycleReaderPower from pollReader.
			
TODO: √ Prompt for settings-save whenever leaving select-setting mode,
			but only if settings have changed.
						
TODO: √ Use Storage.checksumMatch() in Settings.saveSettings()
			to exit before asking user to save, if checksums still match.
						
TODO: √ Don't print first "Password:" in BT serial at startup, until key is pressed.			
			
NOTE: √ If you get compiler warnings about "invalid use of incomplete type SerialPort",
			there is probably something else going on that is related to SerialPort.
			
			Update: I think I fixed this by correcting the forward-declaration stuff.
			
TODO: √ Change name of Menu.adminTimeout() to checkAdminTimeout().
			
TODO: √ In Menu.Loop() and Menu.Begin(), check if each menu has a valid serial_port.






			
/*****  All outstanding items have been moved down here  2020-02-18  *****/

TODO: Change all 'previous_ms' to 'last_<whatever>'.
      Do we still want this?
      
TODO: Code documentation. User documentation.

TODO: Add validation code to storage.h to handle bad storage_name or bad eeprom_address.

TODO: Note that this todo is old and may not be relevant any ore
			Add settings for rfid-reader-add-tag-delay and menu-add-tag-delay,
      so they can be adjusted without re-flashing device.
      Update: add-tag seems to be working well... is this todo necessary?
      
TODO: Make sure all 3 readers are working.
      Do all readers start with 2 and end with 3 ?
      Is each specific Reader subclass storing everything it needs for tag processing?

TODO: Document RGB LED color and pattern meanings for end-user.
      Document RGB usage for developers.
      
TODO:	Add a menu option to change the BT12's advertised name.
	    This could only be done from the HW serial admin menu (obviously).
	    
FIX:  Need some way to recover from sending AT command with no response. Timeout?
      Create a timeout function for waiting for serial input?
      
TODO: Add log line in .ino for initialization of BTserial port.

TODO: Add option to control volume of beeper, and to disable it entirely.
      Is that safe? There should be a warning that it could be dangerous
      to not know when a tag read is growing stale (aging).

TODO: Could the entire SettingsList[] code be put into its own pair of files?
			Would this be any benefit?

TODO: Should run-mode default to 2? (until admin is activated (1) or times out (0)).
			Or is there another way to determine that we're listening for admin mode,
			but it hasn't been activated yet?
			
			Make run-mode like this:
			0. starting up, no menu activated
			1. menu activated by user
			2. live (reader only, no serial read from menus)

TODO: Consider storing in EEPROM last-up-time and total-number-of-runs, just for info.

TODO: Consider making eeprom-addresses automatic, based on sizes of all stored objects.
			state_epradrs = 0
			tags_epradrs  = state_epradrs + sizeof(state-object) + 1
			settings_epradrs = tags_epradrs + sizeof(tags-object) + 1
			
TODO: Change the word 'phase' to 'interval' in Led files, or vise-versa.

TODO: Consider moving RunMode to Controller instead of Menu.

TODO: Make 3 or 5 failed pw attempts exit admin or reboot.

TODO: Settings setters should probably return boolean in case setting fails (esp for password).

TODO: Remove the word 'reader' from Reader functions.
		
TODO: Remove vars or functions that are redundant of each other.
			For example: reader_cycle_total vs readerCycleTotal().
			
			Update: Mostly done.
			
TODO: Check all of the Menu clear/reset functions and where they are used.
			Some of their callings are probably not needed, but which ones?
			
TODO: Need data entry validation for settings. How to do?

TODO: Clean up and refine readers' processTagData functions.

TODO: Refactor serial/log/output handling.

			√ Change BTserial to SWserial.
			
			√ Change Menu::HW and Menu::SW to M1 and M2,
			or just have a single menu instance. Would we lose functionality
			with just a single instance?
			
			Pay attention to the weird dance of AT+ commands in Menu functions.
			
			√ Change bt_baud to sw_serial_baud

			√ Create a SerialPort object that stores the serial-port and
			any specifics of the output device, like whether it's a BLE device,
			whether it has a 'connected' indicator (pin), and whether it's
			a software-serial port.
			
			√ Or better, see the onlinegdb example of custom universal serial class!
			
			ALL serial output should use these SerialPort objects rather than
			passing around raw serial ports and BLE indicators.

			
TODO: Should CanLogToBT() be part of SerialPort class?
			Are there other things (maybe in Menu) that should be part of SerialPort class?
			
TODO: Consider auto-baud management. The ARD would cycle thru the serial devices'
			available baud rates, until it found a working one. Then it would set the device's
			baud and the ARD baud to whatever is best.
			
TODO: Refactoring Menu to use an array of *menu_ary[2] instead of M1, M2.
			Do not use M1,M2 to determine if using BT serial.
			See Menu::Loop() body for example.
			Maybe create a Menu::Menus static var to hold the menu objects.
			
TODO: Refactor Menu to read/set BT module AT commands at startup.
			Maybe this should not be in Menu but in Settings? In it's own file/class?

TODO: Even with bt-status-pin held high, individual input characters are being echoed
			back to unconnected BT module, probably in Menu.checkSerialPort().
			
TODO: I had to disable the startup tag-scanning code in menu loop.
			Find a better way to run this code. It shouldn't be in any single menu's
			loop, it should be in the global Menu::Loop().
			
			Update: I re-enabled and it's working but still needs a refactor.
			
TODO: Re-arrange pins for Pro Mini setup.

TODO: Is it possible to move all global vars and funcs to the main .ino file?

			
			
