/*  RFID PRoximity Sensor Dev Notes  */



TODO: Change all 'previous_ms' to 'last_<whatever>'.
      Do we still want this?

TODO: √ Close fuel switch at startup, so we don't have to wait for software load.
      But track if there was a 'fatal' missing-tag timeout, using EEPROM.
      If there WAS a previous timeout, keep fuel switch OPEN at startup,
      until a valid tag is read (then clear the 'fatal' event from EEPROM.

TODO: √ LED blinker needs a refactor: 1. Simplify, 2. Allow cycle count passed to begin();
      Done except for cycle count.

TODO: √ Implement blinker cycle limit setting.

TODO: √ I think macros need to be coordinated between each file, since they can clobber each other.
      Most macros can be turned into settings (S.<setting>).

TODO: √ Create menu options to set global variables. See above about macros.

TODO: - Create var-to-eeprom address mapping for common settings (to be editable by menu).
      I think this is no longer needed, since we're using EEPROM.put(<with-a-struct-object>).

TODO: √ Provide standard message when admin menu exits/transitions to run mode.

TODO: √ Sort out git repos in Documents/Arduino folder.

TODO: Better code documentation. User documentation.

TODO: √ Don't allow admin mode to extend the startup grace period.

TODO: √ Implement a beeper/buzzer.

TODO: √ I think SerialMenu.run_mode should be a global, since it's needed in multiple classes.
      But where should it live? Then logging can have its own file/class,
      and it can access multiple serial outputs, maybe?
      Update: Maybe run_mode should be a member of the RFID class (Controller class?).

TODO: √ Consolidate SerialMenu handling of input between checkSerialPort() and runCallbacks(),
      so basically everything should be a callback.

TODO: √ Create exitAdmin() function for cleanup & logging.

TODO: √ Make the common blink patterns into constants or S.<setting>.
      fast_blink_intervals[], slow_blink_intervals, startup_admin_timeout_intervals[], etc..
      Still need to store these common intervals in S.<settings>.

TODO: √ Startup grace period needs to END immediately after startup,
      if NO tags are found after the FIRST reader power cycle.
      √ At this point, proximity_state and S.proximity_state need to be fully timed-out.

TODO: - Consider renaming S.proximity_state to S.last_proximity_state.
      Update: proximity_state has been moved to Controller class.

TODO: √ Fix bug in addTagString (I think it's input_mode issue).

TODO: √ Consider a function setProximityState(on-or-off, hight-or-low, whatever).

TODO: Add status_text and updateStatusText() to efficiently display status change in logs.
      This should display proximity_state status as text-label, whenever it changes.
      Use enum StatusText {recent, aging, expired}.
      Update: do we still want this? Is it possible?

TODO: √ Reduce active logging lines in SerialMenu serial port reading.

TODO: √ Show S.<settings> values along with list (in admin mode).

TODO: √ Complete add-tag and delete-tag processes.

TODO: √ Save tags to EEPROM.

TODO: √ Also implement add-tag-from-scan option.

TODO: √ Create version & date-time handling.

TODO: √ Reorganize functions so that "rfid" tag functions are in RFID class,
      "menu" functions in SerialMenu class, and "settings" functions in Settings class.

TODO: √ Consider using variadic macros to create a LOGGER that can print to variable outputs.
      See http://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html
      You might need to include stdarg.h.
      Update: Now have LOG() function, but it isn't a macro.

TODO: √ Tag output to serial console is always the same tag, regardless of what was scanned.
      This holds true even after cold restart of entire board.

TODO: √ Need to ignore READER_CYCLE_HIGH_DURATION at beginning of run mode,
      and cycle reader immediately if no tag found yet. Then immediately
      timeout the tag if still not found.
      This is all because READER_CYCLE_HIGH_DURATION could be set rather high,
      and would allow too much grace period at startup.

TODO: √ cycleReaderPower() isn't triggering when READER_CYCLE_HIGH_DURATION is set to 50,
      and tag-timeout is set to 60. So there's a timing issue when settings are not 5, 25 respectively.
      This was an issue with integer arithmatic and not enough bits.

TODO: √ Maybe refactor proximityStateController() to have smaller conditions and more else-if blocks.
      Also move the subconditions to a single flat if-then-else statement.

TODO: √ Require a CR or CR/LF to enter single characters for SerialMenu.
      This might just be a matter of always using 'line' mode instead of 'char' mode.
      This is necessary to use some terminal apps like BLE-Terminal on ios
      to use the BLE (HM-10) adapter on arduino. Also consider HM-12 for dual BT access (2.1, 4.0).

TODO: √ If proximity state goes low, set reader-cycle-high duration to 3 or 5 seconds.
      Otherwise a flakey tag sitting on top of the reader may miss its only change to be read
      in the scenario where tag-timeout and reader-cycle are both set very high.
      May need a class-global variable for that purpose, so we don't have to mess
      with the S.<setting>.

TODO: √ In normal operation, after admin session timeout (or '0' quit),
      proximity-state is being briefly set to 0, even though the reader hasn't cycled yet.
      This needs to be fixed so startup grace-period NEVER times out without
      first trying a reader power cycle.

TODO: √ Finish converting reader_power_cycle_high_duration to readerPowerCycleHighDuration()

TODO: ! Create protection/failsafe against user-input of bad/empty/out-of-bounds settings.
      For example admin_timeout should NEVER go below 5s,
      And the initial admin_timeout of 2s should not be modifiable by user.
      Generally make sure the Arduino cannot be bricked (requiring a re-flash).
      Update: Some protections have been added to SerialMenu class, but more are needed.
      √ A failsafe boot mode would be helpful.

TODO: √ Create a setting & control for reader-power-cycle polarity.
      Yes, but this is now done in the Reader (sub) classes.

TODO: √ Complete the Reader function that decides what reader to use.

TODO: Convert settings, readers, led patterns to lists & enums, if possible. (settings are done).
      √ Also create settings for all possible current uses of literal data,
      mostly numbers, but maybe some strings?
      Update: This todo item might only make sense for led patterns now,
      since the rest of the entities are already competently handled.
DONE: √ Finally fixed the nasty bugs in RFID and Reader, well most anyway. Ongoing search for UB.

TODO: √ Try swapping the RFID::loop() functions back to the way they were... Still work?

TODO: √ Try converting other RFID uses of tag_last_read_timeout_x_1000 to tagLastReadTimeoutX1000().

TODO: - Consider instance vars in Reader for last_tag_read_id and current_tag_code (hex, I think).
      This is trickier than it seems because it would create a circular requirement between classes.
      Turning the logging features into their own class might help.
      Update: With latest structure, this might be easy now.
      We have a Reader::last_tag_read_id, so this issue might be moot now.

TODO: - I got debug logging to work with BTmenu, but it breaks the RFID cycle.
      It prevents the Reader instance for processing the tag. Is this also a UB whack-a-mole thing?
      Update: the problem appears to be that the RFID serial channel is getting garbled data,
      or at least the program is seeing it as garbled. So, I disabled the BTmenu logging.
      This was probably a UB thing, possibly unrelated to this issue.

TODO: √ Put all literal data that hasn't been incorporated into Settings into macros.

TODO: √ Find a way to use F() to wrap Settings var names in getSettingsByIndex().

TODO: √ When power is first applied, reader-reset-pin appears to be held low indefinitely,
      and reader failes to read tag (after the first one at boot time).
      But even when reader is manually triggered, Ard fails to process the tag successfully.
      A warm (not cold!) reboot of the Ard is necessary to get it working again.
      Update: this only happens in production mode - in debug mode, the reader works fine. Arrrgg!
      √ Update: I might have fixed this - that pin didn't have a pinMode() call, leaving it floating.

TODO: √ Booting under external power in debug mode (debug pin) is causing problems,
      maybe because of a load-order thing with INO_PRINT. But this doesn't seem to happen
      when powered by USB.
      Update: The whole power-on bug was because load order wasn't allowing objects to initialize
      before being used.

TODO: √ Find string operations that have 0 as an argument, and see if they should use '\0' instead.
      According to docs 0 is same as '\0'. They are both int's.

TODO: √ Cleanup & fix bugs in SerialMenu UI.
      √ Prompt
      √ Empty selection for settings-menu.

TODO: √ Output Settings list to HW Serial on starup.
WARN: - Program storage space is at 80% usage.
      - Might need to move some strings back to SRAM (by eliminating F function for some).
      Update: This problem has been aleviated with class-specific debug control.

TODO: √ Create SETTINGS_VALUE_SIZE and use it for calls to getSettingByIndex().

TODO: √ Functionally, everything is working, but S.getChecksum is returning a different number
      between boot and first loop.
      Update: It appears to be the out-of-range dummy ports. Stop using them!
      Ok, this is fixed now! Don't use out-of-range pins, will cause UB.

TODO: - With debug pin, don't change S.enable_debug, because saving any setting
      will then save enable_debug as 1. Just read the pin directly.
      Update: It's ok, just don't boot with debug pin low for an admin session where you save settings.
      You can always hold debug pin low after boot, for temporary debug mode.

TODO: √ Create a Settings function 'debugMode()' which compiles enable_debug with debug-pin.
NOTE: √ Milestone achieved! All basic functions required for real-world use are working.
//

TODO: √ Smooth out UI functionality in SerialMenu - it's still a little confusing what
      mode/state/options we're in at each prompt. Maybe there should be no generic prompts,
      always give a textual hint.

TODO: √ Rearrange main .ino file load order, so initial proximity_state gets written out
      to master-switch-pin as early as possible.

TODO: √ Something is wrong with Tags checksum: it's the same for two different lists!

TODO: - Make tags checksum at least 32-bit. Actually, the 16-bit checksum works now.

TODO: √ Don't load all readers, only load the one we're using.

TODO: √ Create an initial_state (for the grace period) setting: 0=off, 1=on, 2=last-known (S.proximity_state).
      - This may also require an initialState() function to compile the various settings/options at runtime.


FOR REFACTOR:

TODO: √ Move reader functions of RFID class into Reader base,
      then use the loaded reader only for reader functionality,
      including cycling and tag parsing, but not master-switch management
      or led triggering or Tag operations like add, delete, authentication (validation?).
      √ Maybe move reader subclasses to their own readers.cpp file.

TODO: √ Create a Gate/Switch/Controller/State? class that handles all the other stuff RFID does now.
      This class should take a Reader and Blinker instance onboard, since it's the glue
      between those two entities.
      √ Update: This is now just a matter of renaming the RFID class to something else, like Controller.

TODO: √ Then create a Tags class that manages everything tag-related (that's not part of Reader).

TODO: √ Consider again having a Storage class that Tags, Settings, and State all subclass from.

TODO: √ Create a fail-safe button and/or a restore-defaults button. Done: hold pin 12 LOW.

TODO: √ Have BTmenu listen on hardware serial as well.

TODO: - For callback functions or event-response functions, consider "onBufferReady()" naming style.
      Examples: onTagReady(int tag_id), onMenuAddTag(), onSerialPortData(byte).
      Really? Do we want truly event-driven behavior? Would it be better to put a ready-tag
      in a static-member var, and let whatever function pick it up?
      Update: What we've done in SerialMenu with callbacks is sorta like this and works well.

TODO: √ Change Settings::current to title-case Settings::Current.

TODO: √ Don't use strcpy or strncpy. DO use strlcpy (it ensures a null terminator).
NOTE: √ Milestone achieved! Created generic Storage base class, that is also a class template (CRTP).
      √ Settings are currently using this... next are tags (need a Tags class where 1 record is array of tags).

TODO: √ Refactor Storage Class, saving all needed data (including EEPROM address) in Storage instance.
      See storage.h. (also maybe mentioned in other places too, like Tags. storage.h should be the official TODO).
NEXT: √ Storage refactor compiles. Now need to decouple it from the other classes, then review code, then try it.
      √ This has been done with Tags, next do with Settings (then with State - for proximity_state).

TODO: Add validation code to storage.h to handle bad storage_name or bad eeprom_address.

TODO: ! Need validation routine in Tags or Reader to handle bad tag-id.
	    Make sure that checksum is used to validate tags.

TODO: √ Handle reader looping for add-tag entirely within serial-menu class.
      √ Reader class should be unaware of SerialMenu instances.

TODO: √ Implement more efficient GetReader, and move to Reader::GetReader().
      See example file "C++ polymorphism with factory pattern in base.cpp".

TODO: √ Can all specific reader declarations/definitions go into a single file "readers.cpp" ???
      Yes, as long as the GetReader() function is also moved to readers.cpp.

TODO: √ Consider function pointers for SerialMenu callbacks, instead of the large switch/if/then statements.

TODO: √ menuAddTag and addTag are all messed up, in different ways, for both HW & SW interfaces.
      √ Need to make sure that SerialMenu class always cleans up after doing anything with menuAddTag.
      √ Currently, a messy state causes the run-level 0 to behave eratically, switching on/off the proximity-state
      eeeprom setting repeatedly.
      √ Letting SerialMenu timeout naturally and go into run-mode 0, also leaves a mess,
      yielding authorized tags but never activating the switch.
      LED remains in boot state.
      Update: I think most of this issue is solved, was UB from out-of-mem condition.
      Double-check on BTserial interface.

TODO: Remove stuff from SerialMenu and Reader that isn't used any more.
      Remember to check obsolete macros and global vars in .h files.

TODO: √ Include uptime in cycleReaderPower periodic output.

TODO: √ Don't forget failsafe mode and reset-factory-defaults command.
	  Done: Hold pin 12 LOW for failsafe boot. Save any setting to overwrite stored settings.

TODO: - Undo the timing changes around calls to listen() for both soft-serial ports.
      Then split the whole menuAddTag into two functions: one for scanner and one for tty serial.
      Update: timing issues between menu & reader are now working.

TODO: √ Consider disabling all clearing of serial ports, unless they are solving a specific problem.
      It's only done once anyway.

TODO: √ Longer delays may actually hinder serial ports. Consider shorter delays placed more strategically,
      like as long before the port needs to be read as possible. 

TODO: Add settings for rfid-reader-add-tag-delay and menu-add-tag-delay,
      so they can be adjusted without re-flashing device.
      Update: add-tag seems to be working well... is this todo necessary?

TODO: - Implement backspace/delete (ascii 127, 8) for tty. May need to use form-feed chr also (12).
	  So far, having an "Esc" key abort seems to suffice.

TODO: Make sure all 3 readers are working.
      Do all readers start with 2 and end with 3 ?
      Is each specific Reader subclass storing everything it needs for tag processing?

TODO: √ Create FREERAM macro that only runs if debug mode. Use it everywhere u have FreeRam() now,
      except at startup & other key places.

TODO: Remove Blinker from SerialMenu -- there's really no need for it there.
      Partially done: disabled call to Blinker in Menu.

TODO: √ Rename SerialMenu to just Menu.

TODO: √ Rename RFID to Controller or Switch.

TODO: √ Re-enable proximity_state EEPROM retrieve/save (see above for initial_state suggestion).

TODO: Review organization and labels in main .ino file.

TODO: √ Test the latest build, since the logging code changes.

TODO: √ Test changes to RGB implementation.

TODO: √ Store pin assignments in code, not in settings.
      
TODO: √ Store settings in code for all actual physical hardware settings.
	  Pin assignments have now been stored as macro vars (global).
	  Anything that is set through software or digital commands should be
	  adjustable by the user or developer.

TODO: Document RGB LED color and pattern meanings for end-user.
      Document RGB usage for developers.

TODO: Handle saving of blinker interval-set, so previous set can be
      revived after cycle-count goes over num-cycles.
      An led-pattern-stack?
      See note in Led::startPhase(int).
      
TODO: √ Consider reducing reader cycle interval to 3 sec whenever state goes to aging.
      This is because there could be a 30+ second aging length, which would only
      cycle the reader once during that entire time (twice if you count the initial cycle).
      See controller.cpp proximityStateController() and setProximityState().
      
      √ Move the setting of reader_power_cycle_high_duration into
      proximityStateController() and out of setProximityState().
      

TODO: √ Create an off() and on() function that simply sets LED pin accordingly
      but doesn't change cycle state or intervals.
      Update: New go_low() and go_high() set software state and electrical state.
      This works much better than using Off() to clear the red LED when blue wants
      to flash a momentary indicator.

TODO: √ Create a io.h file with all pin assignments.

TODO: √ Make beeper frequency a setting.
      
TODO: √ Allow blinker frequency & pwm to be passed during construction,
      and also at update() or begin().
      
TODO: √ Make sure that defaults for update() and begin() don't override
      values passed during construction (this is handled with negative
      argument-defaults).
      
TODO: √ Since hardcoding pin assignments, find where you had to compromise
      functionality due to waiting for settings to load pin assignments.
      Was it in logging? In LED stuff? In BT admin menu?
      
      √ Hard-coded pin assignments may allow some startup routines to
      start logging earlier, or to begin themselves earlier.

TODO: ? Should the piezo buzzer be located with the RGB LED?
	  What does this mean?

TODO: √ Setting tone_frequency from BTLE terminal gives weird results.
      I think it depends on the terminal client, cuz it works fine with
      "AirTerminal" on iPhone.

TODO: - Activating menu session with BTLE is almost impossible with 2-second window.
      √ Allow increasing admin-startup window with a setting.

TODO: √ Use BT12 connection status indicator (pin 10, low = connected) to 
      tell ARD there is an active connection, or that the connection has dropped.
      
TODO: √ Create a setting 'log_mode'. If true, send all logs to BT-serial port if BT-serial is active.
      This can only be activated during admin mode, however once set, it can be left alone.
      While log_mode is set, any connection to BT-serial port will receive logs, until log_mode is disabled.

	    √ 1. Find out which arguments Serial.print() takes.
	  
  	  √ 2. Then create a wrapper function, ex: "LogToBT()", that takes those args.
  	  	 If conditions are met to write to BTserial,
  	  	 pass the args to BTserial.print(), noting that parameter mismatches
  	     between Serial.print() and the new function may occur and need to be handled.
	  
	    - 3. Optionally, create LPRINT and LPRINTLN macros to wrap the above function.
	  
  	  √ 4. Finally, replace all occurrences of Serial.print() with
  	     the new function (or macro), and you should be good to go.
	  
  	  5. Handle DPRINT and the passing of its args (to BTserial)
  	     after all of the above is working.
  	     
  	  6. Consider a 'Log to BT' command at main menu level, that sets log_to_bt then exits admin.

TODO: √ Create 'Reboot' command.

TODO: √ Change log_to_bt setting to bool (currently integer). Mostly to reduce storage space.

TODO: - Debug scratching sound during timeout beeping, when log_to_bt is set.
      I think it's because log output to BTserial interferes with ARD PWM.
      Probably nothing we can do about it.

TODO: √ Move admin console splash line to after LOG items finish printing
	    (only relavent when BTserial is printing startup logs).
	    Ok, mostly done.
	  
TODO: √ Get settings display to print to BTserial at startup.

TODO: √ Use debug-mode function, instead of raw pin read, in can_print_to_bt logic.

TODO: √ When debug pin is held during run mode, it makes a mess of the reader/controller/blinker/beeper.

TODO: √ There is garbage printing on BTserial at startup, even when log_to_bt is 0 and debug-pin is 1 (off).
      Maybe UB caused by the multiple BTserial declarations.
      
      Update: I think it's due to floating pins, cuz is never happens when soft-rebooted from IDE.
      
TODO: Check to see if any class constructors are using LOG or BTserial in their construction methods.
      They probably should not.
      
      Yes, one of the classes has LOG in its constructor.

TODO: √ Change io.h to global.h, and put externs (like BTserial) in there.

TODO: √ Create a io-setup or globals-setup extern function,
      and put all pin setups in there,
      then call it at beginning of main setup().
      
TODO: √ Debug mode (with debug-pin) now crashes ARD.
      Maybe some kind of interference between io ports or pins?
      
      √ There was UB occuring due to multiple declarations of BTserial.
      Now BTserial is declared & defined in io.h and io.cpp... and it works!
      
TODO: √ Why is WL-125 constructor running twice (see log output)?
      Hmm... it's by design. See GetReader() and TestReader().
      There must be a better way to do this.

TODO: √ Users need to see what readers are available, when selecting in settings.
      This is mostly handled now with PrintReaders (main menu item #7).

TODO: - Consider changing Reader::GetReader() to Reader::Setup()

TODO: - Consider if making Reader or Reader::Reader() a template
      will help reduce redundant/duplicate code in subclass reader defs (in readers.cpp)
      See the old TestReader() function (readers.cpp) for ideas.
      
      Update: I don't think this would help, plus it would require putting the entire
      contents of reader.cpp into reader.h.
      
TODO: √ Make reader index/name mapping 1-based (not zero-based).

WARN: - Use of 'char *var' declarations at static and class level
      may cause out-of-bound strings and UB.
      This may be an issue for the reader-name refactor.
      
      I think we need to give Reader::Name and maybe Reader.reader_name defined length.
      
      Setting this warning aside for now, since none of these items fixed the UB.
      
TODO: √ Change Reader.reader_name() to Reader.name().

TODO: √ Change all '.debugMode() > 0' back to just '.debugMode()'

TODO: √ Add dedicated extern or static var to hold hardware debug state from startup.
      Currently we are using S.enable_debug, which will get set into EEPROM if any
      other settings are stored.
      
FIX:  √ Updating deafult_reader setting using reader list (or main menu #7) fails.
      Turns out you can't just cast an int to char*.
      Turns out the PrintReaders function was overrunning its output buffer var.

TODO: √ Make sure no other Menu code prints to BTserial when it shouldn't.
      Turns out the initial menu prompt was causing BTserial chip to throw "ERROR".
      
FIX:  √ Storage can't use DPRINT cuz Settings and logger.h haven't been loaded yet.
      So just use LOG within #ifdef SO_DEBUG blocks.
      
TODO: √ Don't overwrite existing tag set when loaded tag set has checksum mismatch.
      Just run with a zeroed tag set, but don't save it to eeprom.
      Allow the user to make the decision to save.
      
TODO: √ Move TempDebug to logger or global files.

TODO: Actually, consider consolidating logger and global files
      and moving all debug code from settings to logger/global files.
      
TODO: √ Create a proper logger that consolidates all the c++ macros with the
      existing LOG function.
      
TODO: - Create empty-prompt function for Menu, that just basically pauses and waits for any key
      Then continues on to specified callback. This might help the Reader menu & selection
      prompt that is the first event after the user inputs something.
      
TODO: √ Make reader selection an eternal loop, with only a CR to break out of it.
      This is just like with settings.
      
TODO: √ Missig some log items in BTserial when only log_to_bt is set (no HW pin).
      Yep, because stored Settings have not been loaded yet, causing canLogToBt()
      to return false. Nothing we can do about this. Just use the debug pin, if you
      want to see the earlier log output in the BTserial monitor.

TODO: Debug-logging clobbers HW menu interface when debug-pin is used.
      Logging to HW interface should be minimal when HW serial menu is active.
      
      Ok, now all log-trace output is sent only with level 6.
      Not sure how to handle this issue though, when we need
      to view trace logging for classes with lots of looping log output.
      
TODO: Standard log output should always show what is about to happen, not what just happened.
      This will give you more info in case of a failure/crash/error.
      Debug log output should add the "what just happened" info.
      Or do I have this backwards with regards to standard vs debug output.
      
      Example (good):
        Loading settings
        Loading tags
        Starting controller
        Starting reader
        
      Example (bad):
        Loaded settings
        Loaded reader
        Loaded tags
        Loaded controller
        
TODO: √ Remove unnecessary delay()s.

TODO: √ Create functions for reading/writing to BT12 module.
	  
TODO:	Then add a menu option to change the BT12's advertised name.
	    This could only be done from the HW serial admin menu (obviously).
	  
TODO: Should run_mode and adminTimeout() be stored & handled from Controller (instead of Menu)?
	  
TODO: Review naming of static/extern/global vars and functions.

TODO: √ Only run AT commands to SW serial if module is not connected.

TODO: √ Prevent lockout if SW admin invokes command 9 (send AT commands).

TODO: √ Created basic logging framework and converted Menu class.
      Now upload and try it.
      Then convert other classes.
      
TODO: √ FIX: Tags list at startup shows a single string of letters.
      This was due to several LOG calls with the wrong level.
      I don't think there was any UB happening.
  
TODO: Test all the new logging calls at level 6 with each class _DEBUG enabled.

TODO: Need some way to recover from sending AT command with no response. Timeout?
      Create a timeout function for waiting for serial input.

TODO: Can we poll HW menu in run-mode 0 for simple log-level changes (1, 2, 3, 4, 5, or 6).
      Or would that create a software-serial mess?
      Maybe only when debug button is LOW (or was LOW at startup)... ?
      
TODO: Should debug button take level all the way to max (6)?

TODO: Log level 5 with BTserial connected & with Reader debug enabled causes
      reader/controller confusion when tag is read, leading to false aging mode.
      (it's the reader byte detail that seems to cause the most trouble).
      The problem goes away immediattely when log level is reverted to 4, or when
      BTserial is disconnected. This is likely a sw-serial competition thing,
      since it doesn't happen at all using HW serial monitor.
      
      The only solution may be to always use HW serial to view log output,
      while using BT serial to view deeper levels of output is at-your-own-risk...
      
TODO: OR, try preventing switching of SW serial listener, whenever the RFID reader
      is in the middle of reading a tag. Maybe allow only ONE loop section to operate
      at a time: Either the RFID reader loop, or the BT serial loop.
      But would this break Menu tag functions?
      
TODO: √ Add Controller.status to track which state controller is in,
      ONLY for the purpose of logging change-of-state without spitting
      out gobs of identical log lines.
      
TODO: √ Change log level of reader byte-detail output to 6 (instead of 5).
      This might prevent controller problems when viewing log level 5 (debug pin)
      in BT serial.
      
TODO: √ Prevent settings list for printing at startup if log level < 4.

TODO: Preface each log line with level name.
      How to handle log items that are in the midddle of a line?
      
      Maybe only do this for levels 1-3.
      
      This will require a function prepareDat().
      
TODO: Add log line in .ino for initialization of BTserial port.

TODO: Add option to control volume of beeper, and to disable it entirely.
      Is that safe? There should be a warning that it could be dangerous
      to not know when a tag read is growing stale (aging).
      
      